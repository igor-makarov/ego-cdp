#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { parseArgs } from 'util';
import * as chrome from '../lib/launch/chrome.js';
import * as caddy from '../lib/launch/caddy.js';
import { isRunning } from '../lib/common/pid.js';
import { getProxyPort } from '../lib/common/config.js';
import { runHttpCommand } from '../lib/cdp/http.js';
import { runWsCommand } from '../lib/cdp/ws.js';

async function start() {
  const chromePid = chrome.getPid();
  const caddyPid = caddy.getPid();
  const chromeAlive = chromePid && isRunning(chromePid);
  const caddyAlive = caddyPid && isRunning(caddyPid);

  if (chromeAlive && caddyAlive) {
    console.log(`Already running (chrome ${chromePid}, caddy ${caddyPid}).`);
    return;
  }

  if (chromeAlive !== caddyAlive) {
    console.log('Partial state detected, restarting...');
    stop();
  }

  const cdpPort = await chrome.start();
  if (cdpPort) {
    caddy.start(getProxyPort(), cdpPort);
  }
}

function stop() {
  caddy.stop();
  chrome.stop();
}

async function status() {
  const chromePid = chrome.getPid();
  const caddyPid = caddy.getPid();

  if (!chromePid) {
    console.log('Chrome: no pid');
  } else {
    try {
      const info = JSON.parse(await runHttpCommand({ path: '/json/version' }));
      const guid = info.webSocketDebuggerUrl?.split('/').pop() ?? 'unknown';
      console.log(`Chrome: pid ${chromePid} — ${info.Browser} — browser guid ${guid}`);
    } catch {
      console.log(`Chrome: pid ${chromePid} — CDP not responding`);
    }
  }

  if (!caddyPid) {
    console.log('Caddy: no pid');
  } else {
    console.log(`Caddy: pid ${caddyPid}, proxy port ${getProxyPort()}`);
  }
}

async function http() {
  const { values, positionals } = parseArgs({
    args: process.argv.slice(3),
    options: {
      method: { type: 'string', default: 'GET' },
      output: { type: 'string' },
    },
    allowPositionals: true,
  });

  const urlPath = positionals[0];
  if (!urlPath) {
    console.error('Usage: ego-cdp http [--method=METHOD] [--output=FILE] <url-path>');
    process.exit(1);
  }

  const result = await runHttpCommand({ method: values.method, path: urlPath });

  if (values.output) {
    fs.writeFileSync(values.output, result);
    console.log(`Written to ${values.output}`);
  } else {
    process.stdout.write(result);
  }
}

async function ws() {
  const { values, positionals } = parseArgs({
    args: process.argv.slice(3),
    options: {
      timeout: { type: 'string', default: '60000' },
      output: { type: 'string' },
    },
    allowPositionals: true,
  });

  const [path, message] = positionals;
  if (!path || !message) {
    console.error('Usage: ego-cdp ws <path> <message> [--timeout=ms] [--output=FILE]');
    process.exit(1);
  }

  const result = await runWsCommand({
    path,
    message,
    timeout: parseInt(values.timeout, 10),
  });

  if (values.output) {
    fs.writeFileSync(values.output, result);
    console.log(`Written to ${values.output}`);
  } else {
    process.stdout.write(result);
  }
}

const command = process.argv[2];
switch (command) {
  case 'start':  start();  break;
  case 'stop':   stop();   break;
  case 'status': status(); break;
  case 'http':   http();   break;
  case 'ws':     ws();     break;
  default:
    console.error(`Usage: ${path.basename(process.argv[1])} {start|stop|status|http|ws}`);
    process.exit(1);
}
