#!/usr/bin/env node

const { EnvHttpProxyAgent, setGlobalDispatcher } = require('undici');
const path = require('path');
const chrome = require('../lib/launch/chrome');
const caddy = require('../lib/launch/caddy');

setGlobalDispatcher(new EnvHttpProxyAgent());

const PROXY_PORT = parseInt(process.env.PORT, 10) || 9222;

async function start() {
  const cdpPort = await chrome.start();
  if (cdpPort) {
    caddy.start(PROXY_PORT, cdpPort);
  }
}

function stop() {
  caddy.stop();
  chrome.stop();
}

async function status() {
  const chromePid = chrome.getPid();
  const caddyPid = caddy.getPid();

  if (!chromePid) {
    console.log('Chrome: not running.');
  } else {
    try {
      const res = await fetch(`http://cdp.test:${PROXY_PORT}/json/version`, { signal: AbortSignal.timeout(2000) });
      const info = await res.json();
      console.log(`Chrome: running (pid ${chromePid}) — ${info.Browser}`);
    } catch {
      console.log(`Chrome: running (pid ${chromePid}) — CDP not responding yet.`);
    }
  }

  if (!caddyPid) {
    console.log('Caddy: not running.');
  } else {
    console.log(`Caddy: running (pid ${caddyPid}, proxy port ${PROXY_PORT}).`);
  }
}

const command = process.argv[2];
switch (command) {
  case 'start':  start();  break;
  case 'stop':   stop();   break;
  case 'status': status(); break;
  default:
    console.error(`Usage: ${path.basename(process.argv[1])} {start|stop|status}`);
    process.exit(1);
}
